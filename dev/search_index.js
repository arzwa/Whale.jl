var documenterSearchIndex = {"docs":
[{"location":"cytp450/#Reconciled-tree-inference-example","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"","category":"section"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"using Whale, DynamicHMC, DynamicHMC.Diagnostics, Random, NewickTree, DataFrames\nRandom.seed!(624);\nnothing #hide","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"In this case study, we will perform Bayesian gene tree reconciliation for a single (large) gene family. The data can be found in the example4 directory in the Whale git repository. We first load the data:","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"base  = joinpath(@__DIR__, \"../../example/example-4\")\ntree  = readnw(readline(joinpath(base, \"tree.nw\")))\nmodel = WhaleModel(RatesModel(ConstantDLWGD(λ=0.1, μ=0.2, η=0.9)), tree, .1)\ndata  = read_ale(joinpath(base, \"cytp450.ale\"), model, true)","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"Reading in the single CCD (in the read_ale step is already a rather heavy operation. The CCD has about 5000 unique clades.","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"For Bayesian inference we will use the DynamicHMC interface, using a constant-rates model (i.e. assuming a single duplication and loss rate for the entire tree). The default prior should of course not be chosen lightly, although for our current purposes it is reasonable:","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"prior = Whale.CRPrior()\nproblem = WhaleProblem(data, model, prior)","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"Now we run the actual HMC sampler. Note that we perform a very short run here to reduce build times of the documentation, in reality you'd rather use something like a 1000 iterations.","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"results = mcmc_with_warmup(Random.GLOBAL_RNG, problem, 100,\n    warmup_stages=DynamicHMC.default_warmup_stages(doubling_stages=2))\nposterior = Whale.transform(problem, results.chain)\n@info summarize_tree_statistics(results.tree_statistics)","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"A data frame may be easier to work with (and save to disk)","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"df = Whale.unpack(posterior)\ndescribe(df, :mean, :q025=>x->quantile(x, 0.025), :q975=>x->quantile(x, 0.975))","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"Now we will obtain reconciled trees from the posterior","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"trees = track(problem, posterior)\ntrees[1].trees","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"Note that there are many trees with similar posterior probability, so in other words the maximum a posteriori (MAP) tree is not that meaningful in itself. We can however plot the MAP tree with posterior node probabilities to get an idea of the reconciled tree and the nodes with considerable posterior uncertainty. I will use Luxor.jl together with my small helper library for plotting trees:","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"using PalmTree, Luxor\nimport Luxor: RGB\n\nrectree = trees[1].trees[1].tree\noutdir  = mkpath(joinpath(@__DIR__, \"../assets/\"))\noutpath = joinpath(outdir, \"cytp450-map.svg\")\n\ntl = TreeLayout(rectree, cladogram=true, dims=(400,800))\n@svg begin\n    Luxor.origin(Point(0,20))\n    Luxor.setline(1)\n    setfont(\"Noto sans italic\", 7)\n    colfun = n->n.data.label != \"loss\" ? RGB() : RGB(0.99,0.99,0.99)\n    drawtree(tl, color=colfun)\n    nodemap(tl, prewalk(rectree),\n        (n, p) -> !isleaf(n) ?\n            settext(\"  $(n.data.cred)\", p, valign=\"center\") :\n            settext(\"  $(n.data.name)\", p, valign=\"center\"))\n    nodemap(tl, prewalk(rectree),\n        (n, p) -> n.data.label == \"duplication\" && box(p, 4, 4, :fill))\nend 500 850 outpath","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"Squares show duplication events and internal node labels show the posterior probability of observing the relevant node in the reconciled tree.","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"","category":"page"},{"location":"cytp450/","page":"Reconciled tree inference example","title":"Reconciled tree inference example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"wgd-turing/#Bayesian-inference-using-Turing.jl","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Note this documentation is generated from a julia script using Literate.jl. You can find the associated script by following the 'edit on github' link on top.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"In this example we will use the probabilistic programming language implemented in Turing.jl with Whale to specify Bayesian hierarchical models for gene tree reconciliation in a flexible way","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"using Whale, NewickTree, Distributions, Turing, DataFrames, LinearAlgebra, Random\nusing Plots, StatsPlots\nRandom.seed!(7137);\nnothing #hide","category":"page"},{"location":"wgd-turing/#Using-a-constant-rates-model","page":"Bayesian inference using Turing.jl","title":"Using a constant-rates model","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"First we will do inference for a simple constant-rates model (i.e. assuming a single duplication and loss rate for the entire species tree). First we load the species tree (using the example tree available in the WHale library)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"t = deepcopy(Whale.extree)\nn = length(postwalk(t))  # number of internal nodes","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Now we add two WGD nodes to the tree. We do this by specifying the last common ancestor node for the lineages that share the hypothetical WGD. By default, the added node is halfway between the specified node and its parent.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"insertnode!(getlca(t, \"PPAT\", \"PPAT\"), name=\"wgd_1\")\ninsertnode!(getlca(t, \"ATHA\", \"ATRI\"), name=\"wgd_2\")","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"and we obtain a reference model object, using the constant-rates model with two WGDs","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"θ = ConstantDLWGD(λ=0.1, μ=0.2, q=[0.2, 0.1], η=0.9)\nr = Whale.RatesModel(θ, fixed=(:p,))\nw = WhaleModel(r, t, .1)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Note the last argument to WhaleModel, this is the slice length Δt, here set to 0.1. This determines the discretization of the branches of the species tree, and may affect the accuracy of the ALE likelihood. While the transition probabilities over the slices are exact, the number of slices on a branch constrains the maximum number of duplications possible along the branch. By default, Whale will ensure 5 slices on each branch if your Δt would be chosen too coarse. Note that the information printed to the stdout for the WhaleModel struct gives you this information, e.g. the line","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"10,0,0.292,0.0584,5,\"(MPOL,(PPAT));\"","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"indicates that the branch leading to node 10 (which is not a WGD), has length 0.292 and is sliced in 5 slices of length 0.0584.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"next we get the data (we need a model object for that)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"ccd = read_ale(joinpath(@__DIR__, \"../../example/example-1/ale\"), w)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Now we define the Turing model","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"@model constantrates(model, ccd) = begin\n    λ  ~ Turing.FlatPos(0.)\n    μ  ~ Turing.FlatPos(0.)\n    η  ~ Beta(3,1)\n    q1 ~ Beta()\n    q2 ~ Beta()\n    ccd ~ model((λ=λ, μ=μ, η=η, q=[q1, q2]))\nend","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"In this model we have line by line:","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"λ and μ: the duplication and loss rate, for which we assume an uninformative flat prior\nη: the parameter of the geometric prior distribution on the number of genes at the root (i.e. the Whale likelihood is integrated over a geometric prior for the number of ancestral genes)\nq1: the retention rate for the first WGD (with a uniform prior on [0,1], i.e. Beta(1,1))\nq2: as q1\nccd ~ model(...): here we specify the likelihood, we assume the data (ccd) is iid from the duplication+loss+WGD model with the relevant parameters.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"model = constantrates(w, ccd)\nchain = sample(model, NUTS(), 100, progress=false)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Making some trace plots is straightforward using tools from the Turing probabilistic programming ecosystem","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"aesthetics = (grid=false, size=(500,800), titlefontsize=9,\n              title_loc=:left, guidefont=8, color=:black)\nplot(chain; aesthetics...)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"warning: Warning\nOf course such a chain should be run much longer than in this example! Here a very short chain is presented to ensure reasonable build times for this documentation. Generally, one should at least strive for ESS values exceeding 100 although short chains may be good for exploring and testing different models.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Now let's obtain reconciled trees","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"posterior = DataFrame(chain)\nfun = (m, x)->m((λ=x[:λ], μ=x[:μ], η=x[:η], q=[x[:q1], x[:q2]]))\ntt = TreeTracker(w, ccd, posterior, fun)\ntrees = track(tt)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Note that fun is a function that takes the model object and a row from the posterior data frame, returning a model parameterized by the posterior sample in the row x.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Let's have a look at the first family","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"trees[1].trees","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"We can write these to a file using Whale.writetrees(\"filename.nw\", trees[1].trees) if we would want that.  The maximum a posterior tree for this family is","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"map1 = trees[1].trees[1]\nnwstr(map1.tree)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"with posterior probability","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"map1.freq","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Or maybe all the gene pairs","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"ps = Whale.getpairs(trees, w);\nnothing #hide","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Now let's look at the gene pairs which have a non-zero posterior probability of being derived from WGD node 18 (the P. patens WGD, execute @show w to check the model structure)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"p = filter(x->x[Symbol(\"18_wgd\")] > 0.0, ps)[!,:pair]","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Now we can look at the complete posterior reconciliation distribution for these gene pairs","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"df18 = filter(x->x[:pair] ∈ p, ps)\ndf18[:,[!(all(col .== 0)) for col in eachcol(df18)]]  # filter out all zero columns...","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"The column names are <branch id>_<event>, and the entries are the posterior probability that the gene pair is reconciled to the relevant branch + event combination.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"The following can also be helpful","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"tables = Whale.getwgdtables(trees, ccd, w)\ntables","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Here we have for each WGD event in the tree all gene pairs that have non-zero posterior probability (as measured by the frequency in the posterior sample) to be reconciled to the relevant WGD event.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"A table summarizing events for each branch can be obtained as well","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"smry = Whale.summarize(trees)\nsmry.sum","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"here we have the expected number of duplications, losses, etc for the different branches in the species tree (the row associated with a node corresponds to the branch leasing to that node)","category":"page"},{"location":"wgd-turing/#Using-a-branch-specific-rates-model","page":"Bayesian inference using Turing.jl","title":"Using a branch-specific rates model","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Now we will consider a model with branch-specific duplication and loss rates, using a more complicated hierarchical model with an bivariate uncorrelated relaxed clock prior.  We'll use the same tree as above. The relevant model now is the DLWGD model:","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"params = DLWGD(λ=randn(n), μ=randn(n), q=rand(2), η=rand())\nr = Whale.RatesModel(params, fixed=(:p,))\nw = WhaleModel(r, t, 0.1)\nccd = read_ale(joinpath(@__DIR__, \"../../example/example-1/ale\"), w)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Note that the duplication and loss rates should here be specified on a log-scale for the DLWGD model. We use an LKJ prior for the covariance matrix, specifying a prior for the correlation of duplication and loss rates (ρ) and a prior for the scale parameter τ (see e.g. the stan docs):","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"@model branchrates(model, ccd) = begin\n    η ~ Beta(3,1)\n    ρ ~ Uniform(-1, 1.)\n    τ ~ Exponential()\n    T = typeof(τ)\n    S = [τ 0. ; 0. τ]\n    R = [1. ρ ; ρ 1.]\n    Σ = S*R*S\n    !isposdef(Σ) && return -Inf\n    r = Matrix{T}(undef, 2, n)\n    o = id(getroot(model))\n    r[:,o] ~ MvNormal(zeros(2), ones(2))\n    for i=1:n\n        i == o && continue\n        r[:,i] ~ MvNormal(r[:,o], Σ)\n    end\n    q1 ~ Beta()\n    q2 ~ Beta()\n    ccd ~ model((λ=r[1,:], μ=r[2,:], η=η, q=[q1, q2]))\nend","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"In this model we store the mean duplication and loss rate across branches at the root index (or in other words, we interpret the rates at the root node as the expected rates for the branches in the tree).","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"# chain = sample(branchrates(w, ccd), NUTS(), 100, progress=false)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"I am not running the sampler here for the sake of computation time in generating these docs. Of course, again bear in mind that in real applications you will want to take larger samples, e.g. 1000 instead of 100.","category":"page"},{"location":"wgd-turing/#A-critical-branch-specific-rates-model","page":"Bayesian inference using Turing.jl","title":"A critical branch-specific rates model","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"It may also be of interest to specify a similar model with a single 'turnover' rate for each branch, i.e.  enforcing λ = μ for each branch, but allowing this rate to vary across branches. A birth-death process with this property is said to be a critical birth-death process. It is straightforward to specify a hierarchical model for this:","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"@model critical(model, ccd) = begin\n    η ~ Beta(3,1)\n    σ ~ Exponential()\n    T = eltype(σ)\n    r = Vector{T}(undef, n)\n    o = id(getroot(model))\n    r[o] ~ Turing.Flat()\n    for i=1:n\n        i == o && continue\n        r[i] ~ Normal(r[o], σ)\n    end\n    q1 ~ Beta()\n    q2 ~ Beta()\n    ccd ~ model((λ=r, μ=r, η=η, q=[q1, q2]))\nend\n\nRandom.seed!(54)\nchain = sample(critical(w, ccd), NUTS(), 100, progress=false)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Note that this model seems to be somewhat easier to sample from, as can be judged by the ESS values. The results, although based on a small data set and a very short chain, already seem to suggest that the gene trees contain some evidence for a P. patens WGD (as q1 seems to be decidedly non-zero).","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"posterior = DataFrame(chain)\n\n# function to parameterize a model from a row `x` of the `posterior` data frame\nfunction modelfun(m, x)\n    r = Array(x)[15:31]\n    m((λ=r, μ=r, η=x[:η], q=[x[:q1], x[:q2]]))\nend\n\ntt = TreeTracker(w, ccd, posterior, modelfun)\ntrees = track(tt)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"Here's the summary output","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"smry = Whale.summarize(trees)\nsmry.sum","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"note: Note\nOften it can be beneficial to set the hyperparameter η to a fixed value based on the data. η is the parameter for the shifted geometric prior on the number of genes at the root of the gene tree across families, so that the expected number of genes at the root is 1/η. Under the assumption that the evolutonary process is more or less stationary (i.e. there is no systematic growth or contraction of families across the genome), we may wish to set η to the average number of genes in a family in a genome observed in the data.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference using Turing.jl","title":"Bayesian inference using Turing.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Index","title":"Introduction","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"warning: Warning\nThe latest Whale version is a thorough rewrite of the Whale library, and is still work in progress. For the version as used in Zwaenepoel & Van de Peer (2019), refer to this release (v0.2). Nevertheless, the current version should be safe to use and is much more efficient and convenient (if you know a bit of julia).","category":"page"},{"location":"","page":"Index","title":"Index","text":"Whale provides tools for (genome-wide) amalgamated likelihood estimation (ALE) under a DL+WGD model, which is an approach to infer reconciled gene trees and parameters of a model of gene family evolution given a known species tree.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The ALE approach takes into account uncertainty in the gene tree topology by marginalizing over all tree topologies that can be amalgamated from the so-called conditional clade distribution (CCD). This CCD can be constructed from a sample of the posterior distribution of tree topologies (which can be obtained using any standard software for Bayesian phylogenetics).","category":"page"},{"location":"","page":"Index","title":"Index","text":"More specifically, this library can be used to","category":"page"},{"location":"","page":"Index","title":"Index","text":"Statistically test the absence or presence of hypothetical whole-genome duplication (WGD) events in a species phylogeny\nInfer lineage-specific gene duplication and loss rates for a species phylogeny\nInfer high-quality (reconciled) gene trees given a known species tree using Bayesian gene tree reconciliation cf.  Szöllősi et al.\nAll of the above at once","category":"page"},{"location":"","page":"Index","title":"Index","text":"note: Note\nThis library implements the DL and DL+WGD models. It does not implement models of gene family evolution that take into account horizontal gene transfer, incomplete lineage sorting or gene conversion.","category":"page"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You will need julia-1.x. Fire up a julia REPL by typing julia at the command line enter the package manager interface by typing ], and execute add Whale.","category":"page"},{"location":"#Data-preparation","page":"Index","title":"Data preparation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"To perform analyses with Whale, you will need  ","category":"page"},{"location":"","page":"Index","title":"Index","text":"An ultrametric species tree, with ideally branch lengths in geological time (since this allows straightforward interpretation of parameter estimates.)\nA bunch of ALE files, which summarize the conditional clade distributions (CCDs) for the same bunch of gene families. These can be obtained from a sample of the posterior distribution of gene trees using the ALEobserve tool. A pipeline to obtain these from a set of gene family protein fasta files is available at github.","category":"page"},{"location":"","page":"Index","title":"Index","text":"note: Note\nGene IDs should be prefixed by the name of the species to which the gene belongs as used in the species tree. For example if Arabidopsis thaliana is represented by ATHA in the species tree newick file, then the genes should be prefixed with ATHA_, e.g. ATHA_AT1G05000.","category":"page"},{"location":"","page":"Index","title":"Index","text":"note: Note\nAnalyzing CCDs (ALE files) with a very large number of clades or for very large families can be prohibitive computationally. It is therefore generally advisable that large orthogroups are filtered out based on some criterion (for example using the script orthofilter.py in the scripts directory of the Whale repository). To filter out families with very large numbers of clades in the CCD (which reflects that there is a lot of uncertainty in the gene tree), the scripts ccddata.py and ccdfilter.py can be used. This is a rather ad hoc filtering procedure, but can be useful to filter out families that trouble the analysis.","category":"page"},{"location":"","page":"Index","title":"Index","text":"warning: Warning\nMost analyses in Whale assume that for each family, there is at least one gene in both clades stemming from the root of the species tree. The likelihood in Whale is the conditional likelihood under this assumption. This is to rule out the possibility of de novo gain of a gene family along a branch of the species tree. The orthogroup data should therefore always be filtered to be in accordance with this criterion. This can also be done using the orthofilter.py script.","category":"page"},{"location":"#References","page":"Index","title":"References","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Whale.jl is developed by Arthur Zwaenepoel at the VIB-UGent center for plant systems biology (bioinformatics & evolutionary genomics group). If you use Whale, please cite:","category":"page"},{"location":"","page":"Index","title":"Index","text":"Zwaenepoel, A. and Van de Peer, Y., 2019. Inference of Ancient Whole-Genome Duplications and the Evolution of Gene Duplication and Loss Rates. Molecular biology and evolution, 36(7), pp.1384-1404.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The methods in Whale are heavily inspired by previous work done by other researchers. If you use Whale, consider citing the following two particularly important studies:","category":"page"},{"location":"","page":"Index","title":"Index","text":"[ALE] Szöllősi, G.J., Rosikiewicz, W., Boussau, B., Tannier, E. and Daubin, V., 2013. Efficient exploration of the space of reconciled gene trees. Systematic biology, 62(6), pp.901-912.","category":"page"},{"location":"","page":"Index","title":"Index","text":"[DL+WGD model] Rabier, C.E., Ta, T. and Ané, C., 2013. Detecting and locating whole genome duplications on a phylogeny: a probabilistic approach. Molecular biology and evolution, 31(3), pp.750-762.","category":"page"},{"location":"wgd-dhmc/#Bayesian-inference-using-NUTS-with-DynamicHMC.jl","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"","category":"section"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"In this example case, the basic workflow for assessing WGD hypotheses using Whale will be illustrated. We will use the DynamicHMC library for Bayesian inference.","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"note: Note\nInference in Whale with DynamicHMC.jl supports distributed computing. To use distributed parallelism, start up julia with -p <ncores> (or do using Distributed; addprocs(ncores). Instead of loading Whale with using Whale, use @everywhere using Whale and normally all log-likelihood computations should now run in parallel.","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"using Whale, DynamicHMC, Random, NewickTree, Distributions, DataFrames\nusing DynamicHMC.Diagnostics\nRandom.seed!(562);\nnothing #hide","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Set up the model and the data, here I will use a model with constant duplication and loss rates across the species tree. Note that the tree contains two WGD events (internal nodes labeled with a name starting with wgd).","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"tree  = readnw(\"((MPOL:4.752,(PPAT:2.752)wgd_1:2.0):0.292,(SMOE:4.457,((((OSAT:1.555,(ATHA:0.5548,CPAP:0.5548):1.0002):0.738,ATRI:2.293):1.0)wgd_2:0.225,(GBIL:3.178,PABI:3.178):0.34):0.939):0.587);\")\nn = length(postwalk(tree))\nntaxa = (n+1)÷2\nrates = RatesModel(ConstantDLWGD(λ=0.1, μ=0.1, q=[0.2, 0.3], η=0.9))\nmodel = WhaleModel(rates, tree, 0.1)\ndata  = read_ale(joinpath(@__DIR__, \"../../example/example-1/ale\"), model, true)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"note: Note\nTo use the DynamicHMC interface, the third argument of read_ale should be set to true.","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"And next we set up the Bayesian inference 'problem', using the default priors:","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"prior = Whale.CRPrior()\nproblem = WhaleProblem(data, model, prior)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Now we run NUTS (of course this is a ridicuously short run, and in reality you want to use something like a 1000 iterations. Also, it's better to keep doubling_stages >= 3).","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"results = mcmc_with_warmup(Random.GLOBAL_RNG, problem, 200,\n    warmup_stages=DynamicHMC.default_warmup_stages(doubling_stages=2))\nsummarize_tree_statistics(results.tree_statistics)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Now we obtain the posterior distribution in the form of a data frame","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"posterior = Whale.transform(problem, results.chain)\ndf = Whale.unpack(posterior)\ndescribe(df, :mean, :q025=>x->quantile(x, 0.025), :q975=>x->quantile(x, 0.975))","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"And we can visualize the marginal posterior distributions:","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"using Plots\nkwargs = (bins=20, color=:white, grid=false, legend=false)\nps1 = [histogram(df[!,x], xlabel=x; kwargs...) for x in names(df)]\nkwargs = (color=:black, grid=false, legend=false)\nps2 = [plot(df[!,x], xlabel=x; kwargs...) for x in names(df)]\nplot(ps1..., ps2..., layout=(2,5), size=(900,300), guidefont=font(8))","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"From these results (NB: which are based on a mere 12 gene families), we find little support for the second genome duplication (in the angiosperm branch), i.e. the retention rate q_2 is not markedly different from 0. The WGD on the P. patens tip branch however seems to gain some support, with a posterior mean retention rate (q_1) of about 0.4, which is quite high. However, this is definitely too small a data set to make substantial conclusions!","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"We can obtain reconciled trees sampled from the posterior","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"trees = track(problem, posterior)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Consider the first gene family","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"family1 = trees[1].trees","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Note that the freq field gives the approximate posterior probability of this tree (estimated by the sample frequency). We can get the MAP tree as a newick string","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"nwstr(family1[1].tree)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Now we'll plot the MAP tree","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"using PalmTree, Luxor\nimport Luxor: RGB\n\noutdir  = mkpath(joinpath(@__DIR__, \"../assets/\"))\noutpath = joinpath(outdir, \"dhmc-fam1-map.svg\")\n\nrectree = family1[1].tree\ntl = TreeLayout(rectree, cladogram=true, dims=(300,300))\n@svg begin\n    Luxor.origin(Point(0,20))\n    Luxor.setline(2)\n    setfont(\"Noto sans italic\", 12)\n    colfun = n->n.data.label != \"loss\" ? RGB() : RGB(0.99,0.99,0.99)\n    drawtree(tl, color=colfun)\n    nodemap(tl, prewalk(rectree),\n        (n, p) -> !isleaf(n) ?\n            settext(\"  $(n.data.cred)\", p, valign=\"center\") :\n            settext(\"  $(split(n.data.name, \"_\")[1])\", p, valign=\"center\"))\n    nodemap(tl, prewalk(rectree),\n        (n, p) -> n.data.label == \"duplication\" && box(p, 8, 8, :fill))\n    nodemap(tl, prewalk(rectree),\n        (n, p) -> startswith(n.data.label, \"wgd\") && star(p,3,5,3,0.5,:fill))\nend 500 400 outpath","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"The support values are posterior probabilities for the associated reconciled split. Note that the tree does not contain branch lengths. Duplication events are marked by squares, whereas the WGDs are marked by stars.","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"The events field for each gene family contains a summary of the expected number of events for each branch (where each branch is identified by the node to which the branch leads, as shown in the node column)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"trees[1].events","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"We can get for every gene pair the posterior reconciliation probability. The following data frame can therefore be used to probabilistically assess whether two homologous genes are orthologs, WGD-derived paralogs or non-WGD derived paralogs.","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"pair_pps = Whale.getpairs(trees, model)\nfirst(pair_pps, 5)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Every row of this data frame is a probability distribution over reconciliation events, so each row sums to one, as we can verify:","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"map(sum, eachrow(pair_pps[!,1:end-2]))","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"Take for instance the following gene pair (second row)","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"x = pair_pps[2,1:end-2]\nfor (n, v) in zip(names(x), Array(x))\n    v > 0 && println(n, \": \", v)\nend","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"The posterior probability (under the DL model) that this gene pair traces back to the speciation corresponding to node 17 (i.e. the root) is approximately 0.86, whereas the posterior probability that this gene pair traces back to an ancestral duplication event is 0.14.","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"We can get a WGD-centric view as well. The following retrieves a table for each WGD with all gene tree nodes that have a non-zero posterior probability of being reconciled to that particular WGD node","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"tables = Whale.getwgdtables(trees, data, model)\ntables","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"","category":"page"},{"location":"wgd-dhmc/","page":"Bayesian inference using NUTS with DynamicHMC.jl","title":"Bayesian inference using NUTS with DynamicHMC.jl","text":"This page was generated using Literate.jl.","category":"page"}]
}
