var documenterSearchIndex = {"docs":
[{"location":"wgd-turing/#Bayesian-inference-for-the-DLWGD-model","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"note: Note\nHere it is assumed the reader is already familiar with the material outlined in the Tutorial.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"using Whale, NewickTree, Distributions, Turing, DataFrames, LinearAlgebra\nusing Plots, StatsPlots\nusing Random; Random.seed!(7137);\nnothing #hide","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"plotting defaults","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"default(grid=false, size=(500,800), titlefontsize=9, title_loc=:left, guidefont=8)","category":"page"},{"location":"wgd-turing/#Using-a-constant-rates-model","page":"Bayesian inference for the DLWGD model","title":"Using a constant-rates model","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"First we will do inference for a simple constant-rates model (i.e. assuming a single duplication and loss rate for the entire species tree). First we load the species tree (using the example tree available in the Whale library)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"t = deepcopy(Whale.extree)\nn = length(postwalk(t))  # number of internal nodes","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Now we add two WGD nodes to the tree. We do this by specifying the last common ancestor node for the lineages that share the hypothetical WGD. By default, the added node is halfway between the specified node and its parent.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"insertnode!(getlca(t, \"PPAT\", \"PPAT\"), name=\"wgd_1\")\ninsertnode!(getlca(t, \"ATHA\", \"ATRI\"), name=\"wgd_2\")","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"and we obtain a reference model object, using the constant-rates model with two WGDs","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"θ = ConstantDLWGD(λ=0.1, μ=0.2, q=[0.2, 0.1], η=0.9)\nw = WhaleModel(θ, t, .1, minn=10, maxn=20)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"next we get the data (we need a model object for that)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"data = joinpath(@__DIR__, \"../../example/example-1/ale\")\nccd = read_ale(data, w)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Now we define the Turing model","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"@model constantrates(model, ccd) = begin\n    λ  ~ Exponential()\n    μ  ~ Exponential()\n    η  ~ Beta(3,1)\n    q1 ~ Beta()\n    q2 ~ Beta()\n    ccd ~ model((λ=λ, μ=μ, η=η, q=[q1, q2]))\nend","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"In this model we have line by line:","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"λ and μ: the duplication and loss rate, for which we assume Exponential priors.\nη: the parameter of the geometric prior distribution on the number of genes at the root (i.e. the Whale likelihood is integrated over a geometric prior for the number of ancestral genes)\nq1: the retention rate for the first WGD (with a uniform prior on [0,1], i.e. Beta(1,1))\nq2: as q1\nccd ~ model(...): here we specify the likelihood, we assume the data (ccd) is iid from the duplication+loss+WGD model with the relevant parameters.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"chain0 = sample(constantrates(w, ccd), NUTS(), 200)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Making some trace plots is straightforward using tools from the Turing probabilistic programming ecosystem","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"plot(chain0, size=(700,900))","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"We can compute Bayes factors for the WGD hypotheses","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"summarize(chain0[[:q1,:q2]], Whale.bayesfactor)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"This is the log10 Bayes factor in favor of the q = 0 model. A Bayes factor smaller than -2 could be considered as evidence in favor of the q ne 0 model compared to the q=0 model. This in itself need not say much, as it says nothing about how well the model actually fits the data.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"warning: Warning\nOf course the chain should be run longer than in this example! Here a short chain is presented to ensure reasonable build times for this documentation. Generally, one should at least strive for ESS values exceeding at least 100, although short chains may be good for exploring and testing different models.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Now let's obtain reconciled trees","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"posterior = DataFrame(chain0)\nffun = (m, x)->m((λ=x[:λ], μ=x[:μ], η=x[:η], q=[x[:q1], x[:q2]]))\ntt = TreeTracker(w, ccd, posterior, ffun)\ntrees = track(tt, 1000)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Note that fun is a function that takes the model object and a row from the posterior data frame, returning a model parameterized by the posterior sample in the row x.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Let's have a look at the first family","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"trees[1].trees","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"We can write these to a file using Whale.writetrees(\"filename.nw\", trees[1].trees) if we would want that.  The maximum a posterior tree for this family is","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"map1 = trees[1].trees[1]\nnwstr(map1.tree)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"with posterior probability","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"map1.freq","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Or maybe all the gene pairs","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"ps = Whale.getpairs(trees, w);\nnothing #hide","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Now let's look at the gene pairs which have a non-zero posterior probability of being derived from WGD node 18 (the P. patens WGD, execute @show w to check the model structure)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"p = filter(x->x[Symbol(\"18_wgd\")] > 0.0, ps)[!,:pair]","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Now we can look at the complete posterior reconciliation distribution for these gene pairs","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"df18 = filter(x->x[:pair] ∈ p, ps)\ndf18[:,[!(all(col .== 0)) for col in eachcol(df18)]]  # filter out all zero columns...","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"The column names are <branch id>_<event>, and the entries are the posterior probability that the gene pair is reconciled to the relevant branch + event combination.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Here we have for each WGD event in the tree all gene pairs that have non-zero posterior probability (as measured by the frequency in the posterior sample) to be reconciled to the relevant WGD event.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"A table summarizing events for each branch can be obtained as well","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"smry = Whale.summarize(trees)\nsmry.sum","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"here we have the expected number of duplications, losses, etc. per family for the different branches in the species tree (the row associated with a node corresponds to the branch leading to that node)","category":"page"},{"location":"wgd-turing/#Maximum-likelihood-estimation","page":"Bayesian inference for the DLWGD model","title":"Maximum-likelihood estimation","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"using Optim\nresult = optimize(constantrates(w, ccd), MLE())","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"One could now compute the likelihood using the model without WGD 1 and/or 2 and compare the likelihoods using a likelihood ratio test as in Rabier et al. (2014) to assess whether the data is compatible with the hypothesis q = 0 (which should represent absence of a WGD).","category":"page"},{"location":"wgd-turing/#Using-a-branch-specific-rates-model","page":"Bayesian inference for the DLWGD model","title":"Using a branch-specific rates model","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Now we will consider a model with branch-specific duplication and loss rates, using a more complicated hierarchical model with an uncorrelated relaxed clock model.  We'll use the same tree as above. The relevant model now is the DLWGD model:","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"θ = DLWGD(λ=zeros(n), μ=zeros(n), q=rand(2), η=rand())\nw = WhaleModel(θ, t, 0.1)\nccd = read_ale(data, w)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Note that the duplication and loss rates should here be specified on a log-scale for the DLWGD model. We assume a Normal prior for the mean duplication and loss rates, and assume the log-scale branch-specific rates to be distributed according to a multivariate normal with diagonal covariance matrix tau I. We assume duplication and loss rates to be independent.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"@model branchrates(model, n, ccd, ::Type{T}=Float64) where T = begin\n    η ~ Beta(3,1)\n    λ̄ ~ Normal(log(0.15), 2)\n    μ̄ ~ Normal(log(0.15), 2)\n    τ ~ Exponential(0.1)\n    λ ~ MvNormal(fill(λ̄, n-1), τ)\n    μ ~ MvNormal(fill(μ̄, n-1), τ)\n    q1 ~ Beta()\n    q2 ~ Beta()\n    ccd ~ model((λ=λ, μ=μ, η=η, q=[q1, q2]))\nend","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"... and sample (this takes a bit longer!)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"chain1 = sample(branchrates(w, n, ccd), NUTS(), 200)","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"Make a plot for the retention parameters","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"plot(chain1[[:q1,:q2]], size=(700,300))","category":"page"},{"location":"wgd-turing/#Posterior-predictive-simulations","page":"Bayesian inference for the DLWGD model","title":"Posterior predictive simulations","text":"","category":"section"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"We can do posterior predictive simulations to assess model fit. There are of course many possible posterior predictive observables that we may employ to do so. The approach below is but one that is (partially) implemented. Here we compare simulated number of events for each branch with reconstructed number of events for each branch. That is, for N samples from the posterior, we (1) simulate a data set of the size of our empirical data set and (2) sample a reconciled tree for each gene family. We then compare, for instance, the number of duplications on the branch leading to node m in the two simulated sets. If the model fits these should be similar.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"We need a function to get a parameterized model from a chain iterate:","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"function mfun(M, x)\n    q1 = get(x, :q1).q1[1]\n    q2 = get(x, :q2).q2[1]\n    λ = vec(vcat(get(x, :λ).λ...))\n    μ = vec(vcat(get(x, :μ).μ...))\n    η = get(x, :η).η[1]\n    M((λ=λ, μ=μ, q=[q1,q2], η=η))\nend","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"The following will then do 100 posterior predictive simulations","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"pps = Whale.ppsims(chain1, mfun, w, ccd, 100);\nnothing #hide","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"and we make a plot for duplication events","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"lab = \"duplication\"\nps = map(w.order) do mnode\n    l = \"$(id(mnode))_$lab\"\n    dots = map(x->(x[1][l], x[2][l]), pps)\n    xmn, xmx = extrema(vcat(first.(dots), first.(dots)))\n    scatter(dots, color=:black, ms=2, alpha=0.5, legend=false,\n            xlabel=\"\\$y\\$\", ylabel=\"\\$\\\\tilde{y}\\$\",\n            title=Whale.cladelabel(mnode),\n            xlim=(xmn-0.5,xmx+0.5), xticks=xmn:1:xmx)\n    plot!(x->x, color=:lightgray)\nend\nplot(ps..., size=(700,600))","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"one can of course also compare loss events, speciation events, WGD-derived duplicates etc.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"The above is somewhat more informative when analyzing more data. Using this approach on chain0 and comparing against the results displayed here, one could for instance check whether the constant rates assumption is strongly violated or not. If the dots in these plots are not systematically above or below the 1-1 line, at least this aspect of the data is explained well by the model.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"note: Note\nI know that this, and the sampling methods for reconciled trees, should be implemented in a somewhat more consistent and user-friendly style. It's on the to-do list.","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"","category":"page"},{"location":"wgd-turing/","page":"Bayesian inference for the DLWGD model","title":"Bayesian inference for the DLWGD model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Index","title":"Introduction","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Whale provides tools for (genome-wide) amalgamated likelihood estimation (ALE) under a DLWGD model, which is an approach to infer reconciled gene trees and parameters of a model of gene family evolution given a known species tree. The ALE approach takes into account uncertainty in the gene tree topology by marginalizing over all tree topologies that can be amalgamated from the so-called conditional clade distribution (CCD). This CCD can be constructed from a sample of the posterior distribution of tree topologies (which can be obtained using any standard software for Bayesian phylogenetics, see below).","category":"page"},{"location":"","page":"Index","title":"Index","text":"More specifically, this library can be used to","category":"page"},{"location":"","page":"Index","title":"Index","text":"Statistically assess hypothetical whole-genome duplication (WGD) events in a species phylogeny.\nInfer lineage-specific gene duplication and loss rates for a species phylogeny.\nInfer high-quality (reconciled) gene trees given a known species tree using Bayesian gene tree reconciliation cf. Szöllősi et al.\nConduct Bayesian orthology inference.\nAll of the above at once.","category":"page"},{"location":"","page":"Index","title":"Index","text":"note: Note\nThis library implements the DL and DLWGD models. It does not implement models of gene family evolution that take into account horizontal gene transfer, incomplete lineage sorting or gene conversion.","category":"page"},{"location":"#Installation","page":"Index","title":"Installation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"You will need julia-1.x. Fire up a julia REPL by typing julia at the command line enter the package manager interface by typing ], and execute add Whale.","category":"page"},{"location":"#Data-preparation","page":"Index","title":"Data preparation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"To perform analyses with Whale, you will need  ","category":"page"},{"location":"","page":"Index","title":"Index","text":"An ultrametric species tree, with ideally branch lengths in geological time (since this allows straightforward interpretation of parameter estimates.)\nA bunch of ALE files, which summarize the conditional clade distributions (CCDs) for the same bunch of gene families. These can be obtained from a sample of the posterior distribution of gene trees (or bootstrap replicates, if you prefer) using the ALEobserve tool.","category":"page"},{"location":"","page":"Index","title":"Index","text":"note: Note\nGene IDs should be prefixed by the name of the species to which the gene belongs as used in the species tree. For example if Arabidopsis thaliana is represented by ATHA in the species tree newick file, then the genes should be prefixed with ATHA_, e.g. ATHA_AT1G05000.","category":"page"},{"location":"","page":"Index","title":"Index","text":"note: Note\nIf one wants to conduct gene tree reconciliation using Whale assuming known gene trees as input, one can simply construct a trivial CCD for each gene tree using ALEobserve (i.e. construct a CCD for a 'sample' consisting of a single gene tree).","category":"page"},{"location":"","page":"Index","title":"Index","text":"note: Note\nAnalyzing CCDs (ALE files) with a very large number of clades or for very large families can be prohibitive computationally. It is therefore generally advisable that large orthogroups are filtered out based on some criterion (for example using the script orthofilter.py in the scripts directory of the Whale repository). To filter out families with very large numbers of clades in the CCD (which reflects that there is a lot of uncertainty in the gene tree), the scripts ccddata.py and ccdfilter.py can be used. This is a rather ad hoc filtering procedure, but can be useful to filter out families that trouble the analysis.","category":"page"},{"location":"","page":"Index","title":"Index","text":"warning: Warning\nMost analyses in Whale assume that for each family, there is at least one gene in both clades stemming from the root of the species tree. The likelihood in Whale is the conditional likelihood under this assumption. This is to rule out the possibility of de novo gain of a gene family along a branch of the species tree. The orthogroup data should therefore always be filtered to be in accordance with this criterion. This can also be done using the orthofilter.py script.","category":"page"},{"location":"#References","page":"Index","title":"References","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Whale.jl is developed by Arthur Zwaenepoel at the VIB-UGent center for plant systems biology (bioinformatics & evolutionary genomics group). If you use Whale, please cite:","category":"page"},{"location":"","page":"Index","title":"Index","text":"Zwaenepoel, A. and Van de Peer, Y., 2019. Inference of Ancient Whole-Genome Duplications and the Evolution of Gene Duplication and Loss Rates. Molecular biology and evolution, 36(7), pp.1384-1404.","category":"page"},{"location":"","page":"Index","title":"Index","text":"The methods in Whale are heavily inspired by previous work done by other researchers. If you use Whale, consider citing the following two particularly important studies:","category":"page"},{"location":"","page":"Index","title":"Index","text":"[ALE] Szöllősi, G.J., Rosikiewicz, W., Boussau, B., Tannier, E. and Daubin, V., 2013. Efficient exploration of the space of reconciled gene trees. Systematic biology, 62(6), pp.901-912.","category":"page"},{"location":"","page":"Index","title":"Index","text":"[DL+WGD model] Rabier, C.E., Ta, T. and Ané, C., 2013. Detecting and locating whole genome duplications on a phylogeny: a probabilistic approach. Molecular biology and evolution, 31(3), pp.750-762.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial aims to make users familiar with the key components of the Whale library. The material on this page should enable a user familiar with Bayesian statistics or optimization to make use of the package for conducting inference for models of gene family evolution from gene trees.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nThis tutorial will not show how to get the input data (CCDs) for running analyses with Whale. Please consider the Introduction page.","category":"page"},{"location":"tutorial/#.-Introduction","page":"Tutorial","title":"0. Introduction","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Whale is a library for conducting statistical inference for phylogenetic birth-death process models of gene family evolution and statistical gene tree – species tree reconciliation using the amalgamated likelihood approximation (Szöllősi et al. 2014) to the marginal sequence likelihood.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us unpack the above. Consider a sequence alignment y, a known species tree S, a model of sequence evolution with parameters phi and a model of gene family evolution with parameters theta. The likelihood of a sequence alignment y, marginalizing over gene tree topologies, is given by:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p(yphithetaS) = sum_G in mathcalG_yintp(yG t phi)\n  p(G tS theta)dt","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Where we sum over the set mathcalG_y of all possible gene trees on the alignment y and integrate over all possible node ages in the tree t. Clearly, this represents a very challenging inference problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When we are mainly interested in inference under the model of gene family evolution (e.g. inference of reconciled trees, orthology relationships, duplication and loss rates, etc.), we can adopt the ALE approximation to this marginal likelihood, which takes the following form","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p(ythetaS) = sum_G in mathcalG_y p(yG) p(GStheta) approx\nsum_G in mathcalG_y xi_y(G) p(GStheta) = q(ythetaS)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(note that p(yG) = int_phi p(yphiG))). Here xi_y(G) serves as an approximation to the sequence likelihood, and is assumed to be proportional to p(yG).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the ALE approach (for amalgamated likelihood estimation), we obtain a xi_y(G) by constructing a conditional clade distribution (CCD) from a sample of the posterior distribution of gene trees under the model of sequence evolution, and using the probability mass function associated with this CCD. That is xi_y(G) propto p(yG)p(G) under the model of sequence evolution alone, which is propto p(yG) when a uniform prior is used for G. The reason we restrict ourselves to a CCD as approximating family is that this allows for efficient computation of the potentially huge sum sum_G in mathcalG_y xi_y(G) p(GStheta), as was shown by Szöllősi et al.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With an approximation to p(ythetaS) in hand, we can conduct inference for the parameters of the model of gene family evolution theta using either Bayesian inference or maximum likelihood estimation (MLE). The Whale library implements inferential tools for phylogenetic birth-death process (BDP) models of gene family evolution, potentially with ancient whole-genome duplication (WGDs). Parameter inferences under the models which include ancient WGDs can be used to assess WGD hypotheses based on gene trees. With a little more work, we can also estimate (or rather sample) gene tree topologies and their reconciliations under the model of gene family evolution and the ALE approximation. This then allows us to conduct probabilistic orthology assignments and ancestral gene family reconstructions. Viewed in this regard, the ALE and Whale approach provide a methodology to conduct model-based gene tree – species tree reconciliation and tree-based orthology inference, while taking into account the uncertainty in the gene tree topology.","category":"page"},{"location":"tutorial/#.-Loading-data-and-the-WhaleModel","page":"Tutorial","title":"1. Loading data and the WhaleModel","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before moving on to actual inference, we illustrate the key components of the library. We start by loading the data and constructing a simple model object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The minimally required packages to do something useful are the following:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Whale, NewickTree","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will also load Plots.jl to have some graphics.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\ndefault(legend=false, grid=false, framestyle=:box, size=(500,300))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will use the land plant example data set (which is available in the github repository). We shall need a species tree","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"datadir = joinpath(@__DIR__, \"../data/landplant\")\ntree = readnw(readline(joinpath(datadir, \"speciestree.nw\")))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"... and a model object","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rates = ConstantDLWGD(λ=0.1, μ=0.2, η=1/1.5)\nmodel = WhaleModel(rates, tree, 0.01)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rates represents the model parameters: here we assume DLWGD (duplication, loss and WGD) model with constant duplication and loss rates across the species tree. We assume a duplication rate lambda = 01 and loss rate mu = 02, with the number of genes at the root of a gene family distributed according to a Geometric distribution with mean 15 (i.e. eta = 115). We combine the rates which parameterize the phylogenetic BDP model with the species tree in a WhaleModel object (model). The last argument to WhaleModel (here 0.01) determines the discretization of the species tree. This entails that we assume there to be at most one represented gene duplication event in each time slice of length 001. This parameter should be adjusted relative to the branch lengths of the species tree.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that when the model object is printed to the screen, we get quite some information. In particular, under Model structure we get a CSV formatted table with header node_id, wgd_id, distance, Δt, n, subtree, here n shows the number of slices for the relevant branch of the species tree, i.e. the maximum number of represented gene duplication events along that branch. It is best to check whether these are large enough (at least 10 or so, except for the root).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can load the gene tree distributions (CCDs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"data = read_ale(joinpath(datadir, \"100fams\"), model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that to load the CCDs (gene tree distributions), we need a WhaleModel object!","category":"page"},{"location":"tutorial/#.-The-loglikelihood","page":"Tutorial","title":"2. The loglikelihood","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now, for instance, compute the log-likelihood for the first family","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ℓ = logpdf(model, data[1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Or, assuming iid data, for the full data","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ℓ = logpdf(model, data)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can easily reparameterize the model using the following syntax:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"model = model((λ=0.2,μ=0.1))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"So that, for instance, we can easily graph a likelihood surface in the following way","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(0:0.01:2, λ->logpdf(model((λ=λ, μ=λ)), data[1]), ylabel=\"\\$\\\\ell\\$\", xlabel=\"\\$\\\\lambda\\$\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(where we assumed lambda = mu). Note that the loglikelihood can be differentiated using forward-mode automatic differentiation (AD) with ForwardDiff.jl. The library is currently not compatible with reverse mode AD or other fancy stuff.","category":"page"},{"location":"tutorial/#.-Backtracking-reconciled-trees","page":"Tutorial","title":"3. Backtracking reconciled trees","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can sample a reconciled tree under the phylogenetic BDP using stochastic backtracking. That is, we sample a reconciled gene tree conditional on the unreconciled gene tree topology distribution and the likelihood under the model of gene family evolution:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ℓ = logpdf!(model, data)\nG = Whale.backtrack(model, data[1])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the logpdf! step is crucial: the data is modified during the likelihood computations to enable backtracking.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The reconciled tree consists of nodes which look like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"prewalk(G)[1:10]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here σ marks the species tree branch/node to which the gene tree node is reconciled. If a gene tree node is marked as a duplication with σ=3, this means for instance that this node represents a duplication event along the branch leading to node 3 of the species tree. t marks the time point along the branch of the species tree, going from present to past, where the gene tree node is reconciled to. Speciation events have t=0 because they are mapped to the nodes in the species tree, instead of the branches (as duplication events are).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are some plotting functions available, some better than others. The following plots the reconciled tree inside the species tree (duplication nodes in red, speciation nodes in blue)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(model, G, sscale=50.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"toy around with sscale if the plot doesn't look good (or implement a new function and do a pull request!). Simply plotting the reconciled tree is also possible","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(G, right_margin=30Plots.mm, size=(500,500))","category":"page"},{"location":"tutorial/#.-Inference","page":"Tutorial","title":"4. Inference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With likelihoods available, one has many possibilities for conducting inference. I suggest using the Turing.jl library for probabilistic programming, potentially together with Optim.jl for maximum likelihood or maximum a posteriori estimation. You might want to get familiar with the basic syntax for specifying probabilistic models using Turing, please consult the relevant docs and tutorials at https://turing.ml.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Turing, Optim","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can for instance consider the lambda = mu model for the first family, i.e. the problem for which we computed the likelihood curve above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@model simplemodel(M, y, ::Type{T}=Float64) where T = begin\n    λ ~ Exponential(0.2)\n    y ~ M((λ=λ, μ=λ, q=T[]))\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we specify a probabilistic model with an Exponential(1) prior for the duplication (=loss) rate using Turing.jl syntax. Some minor annoyances with type stability lead to the [...] ::Type{T}=Float64) where T part and the explicit passing of q=T[] in the model object, sorry.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can obtain a sample from the posterior using the NUTS algorithm","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"chain = sample(simplemodel(model, data[1]), NUTS(), 200)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That makes sense. Alternatively, we can conduct MLE using Optim and Turing:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"optimize(simplemodel(model, data[1]), MLE())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Using probabilistic programs we can construct complicated hierarchical models of gene family evolution. Here's a very slight elaboration of the previous model, where we now assign a hyperprior to th number of lineages at the root:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@model secondmodel(M, y, ::Type{T}=Float64) where T = begin\n    λ ~ Exponential(0.2)\n    η ~ Beta(4,2)\n    y ~ M((λ=λ, μ=λ, q=T[], η=η))\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we consider the first 10 families as data this time","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"chain = sample(secondmodel(model, data[1:10]), NUTS(), 200)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's compare the eta prior and posterior:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"histogram(chain[:η], normalize=true, color=:white, xlabel=\"\\$\\\\eta\\$\", ylabel=\"probability density\")\nplot!(0:0.01:1, x->pdf(Beta(4,2), x))","category":"page"},{"location":"tutorial/#.-Sampling-reconciled-trees-from-the-posterior","page":"Tutorial","title":"5. Sampling reconciled trees from the posterior","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface for sampling reconciled trees from the posterior by stochastic backtracking is not so user-friendly yet and is due for some updates, but it is not difficult either. We first cast the chain as a data frame:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DataFrames\ndf = DataFrame(chain);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We have to define a function which takes a model and a row from the dataframe (i.e. a sample from the posterior) and returns a model parameterized by that sample.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"modelfun(M, x) = M((λ=x[:λ], μ=x[:λ], η=x[:η]))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next we define the tracker","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tracker = TreeTracker(model, data[1:10], df, modelfun)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and we sample for each family 100 reconciled trees from the posterior, using the posterior sample in df.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"out = track(tracker, 100)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Each family has a RecSummary object, which among other things stores the sampled reconciled trees","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"out[1].trees","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is the MAP tree of the first family:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"out[1].trees[1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We plot the MAP tree for the first family","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(out[1].trees[1].tree, cred=true, size=(500,500), right_margin=30Plots.mm)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The numbers associated with each node indicate the estimated posterior probability that the reconciled tree contains this split reconciled as a duplication/speciation on that particular branch of the species tree.","category":"page"},{"location":"tutorial/#.-Events-and-orthology","page":"Tutorial","title":"6. Events and orthology","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can summarize the number of events on each branch of the species tree using the following function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"smry = Whale.summarize(out)\nsmry.sum","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we summary[1,\"duplication_mean\"] will for instance record the posterior expected number of duplications per family along the branch leading to node 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Another useful output are the posterior probabilities for pairs of genes to be derived from certain events in the species tree","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pairs = Whale.getpairs(out, model);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For instance, we can take a look at the first 10 gene pairs in this data frame. We first filter out all irrelevant columns:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"idx = map(x->!all(x .== 0), eachcol(pairs[1:10,:]))\nsubset = pairs[1:10,idx]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The estimated posterior probabilty that gene pair","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"subset[1,\"pair\"]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"... is derived from a duplication along the branch leading to node 21 is","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"subset[1,\"21_duplication\"]","category":"page"},{"location":"tutorial/#.-Going-further","page":"Tutorial","title":"7. Going further","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For more details with regard to, for instance, the inference of ancient WGDs, or fitting more complicated model, consider having a look at the examples. If there are questions, comments, issues, or anything else, feel free to open issues on the gitub repository.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
