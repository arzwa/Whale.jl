<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Whale.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Whale.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#.-Introduction"><span>0. Introduction</span></a></li><li><a class="tocitem" href="#.-Loading-data-and-the-WhaleModel"><span>1. Loading data and the <code>WhaleModel</code></span></a></li><li><a class="tocitem" href="#.-The-loglikelihood"><span>2. The loglikelihood</span></a></li><li><a class="tocitem" href="#.-Backtracking-reconciled-trees"><span>3. Backtracking reconciled trees</span></a></li><li><a class="tocitem" href="#.-Inference"><span>4. Inference</span></a></li><li><a class="tocitem" href="#.-Sampling-reconciled-trees-from-the-posterior"><span>5. Sampling reconciled trees from the posterior</span></a></li><li><a class="tocitem" href="#.-Events-and-orthology"><span>6. Events and orthology</span></a></li><li><a class="tocitem" href="#.-Going-further"><span>7. Going further</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../wgd-turing/">Bayesian inference for the DLWGD model</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/arzwa/Whale.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial aims to make users familiar with the key components of the Whale library. The material on this page should enable a user familiar with Bayesian statistics or optimization to make use of the package for conducting inference for models of gene family evolution from gene trees.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This tutorial will not show how to get the input data (CCDs) for running analyses with Whale. Please consider the <a href="../#Introduction">Introduction</a> page.</p></div></div><h2 id=".-Introduction"><a class="docs-heading-anchor" href="#.-Introduction">0. Introduction</a><a id=".-Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#.-Introduction" title="Permalink"></a></h2><p>Whale is a library for conducting <strong>statistical inference for phylogenetic birth-death process models of gene family evolution</strong> and <strong>statistical gene tree – species tree reconciliation</strong> using the <strong>amalgamated likelihood approximation</strong> (Szöllősi et al. 2014) to the marginal sequence likelihood.</p><p>Let us unpack the above. Consider a sequence alignment <span>$y$</span>, a known species tree <span>$S$</span>, a model of sequence evolution with parameters <span>$\phi$</span> and a model of gene family evolution with parameters <span>$\theta$</span>. The likelihood of a sequence alignment <span>$y$</span>, marginalizing over gene tree topologies, is given by:</p><p class="math-container">\[p(y|\phi,\theta,S) = \sum_{G \in \mathcal{G}_y}{\int}p(y|G, t, \phi)
  p(G, t|S, \theta)dt\]</p><p>Where we sum over the set <span>$\mathcal{G}_y$</span> of all possible gene trees on the alignment <span>$y$</span> and integrate over all possible node ages in the tree <span>$t$</span>. Clearly, this represents a very challenging inference problem.</p><p>When we are mainly interested in inference under the model of gene family evolution (e.g. inference of reconciled trees, orthology relationships, duplication and loss rates, etc.), we can adopt the ALE approximation to this marginal likelihood, which takes the following form</p><p class="math-container">\[p(y|\theta,S) = \sum_{G \in \mathcal{G}_y} p(y|G) p(G|S,\theta) \approx
\sum_{G \in \mathcal{G}_y} \xi_y(G) p(G|S,\theta) := q(y|\theta,S)\]</p><p>(note that <span>$p(y|G) = \int_\phi p(y,\phi|G)$</span>)). Here <span>$\xi_y(G)$</span> serves as an approximation to the sequence likelihood, and is assumed to be proportional to <span>$p(y|G)$</span>.</p><p>In the ALE approach (for <em>amalgamated likelihood estimation</em>), we obtain a <span>$\xi_y(G)$</span> by constructing a <em>conditional clade distribution</em> (CCD) from a sample of the posterior distribution of gene trees under the model of sequence evolution, and using the probability mass function associated with this CCD. That is <span>$\xi_y(G) \propto p(y|G)p(G)$</span> under the model of sequence evolution alone, which is <span>$\propto p(y|G)$</span> when a uniform prior is used for <span>$G$</span>. The reason we restrict ourselves to a CCD as approximating family is that this allows for efficient computation of the potentially huge sum <span>$\sum_{G \in \mathcal{G}_y} \xi_y(G) p(G|S,\theta)$</span>, as was shown by Szöllősi et al.</p><p>With an approximation to <span>$p(y|\theta,S)$</span> in hand, we can conduct inference for the parameters of the model of gene family evolution <span>$\theta$</span> using either Bayesian inference or maximum likelihood estimation (MLE). The Whale library implements inferential tools for <strong>phylogenetic birth-death process (BDP) models</strong> of gene family evolution, potentially with <strong>ancient whole-genome duplication (WGDs)</strong>. Parameter inferences under the models which include ancient WGDs can be used to assess WGD hypotheses based on gene trees. With a little more work, we can also estimate (or rather sample) gene tree topologies and their reconciliations under the model of gene family evolution and the ALE approximation. This then allows us to conduct probabilistic orthology assignments and ancestral gene family reconstructions. Viewed in this regard, the ALE and Whale approach provide a methodology to conduct model-based gene tree – species tree reconciliation and tree-based orthology inference, while taking into account the uncertainty in the gene tree topology.</p><h2 id=".-Loading-data-and-the-WhaleModel"><a class="docs-heading-anchor" href="#.-Loading-data-and-the-WhaleModel">1. Loading data and the <code>WhaleModel</code></a><a id=".-Loading-data-and-the-WhaleModel-1"></a><a class="docs-heading-anchor-permalink" href="#.-Loading-data-and-the-WhaleModel" title="Permalink"></a></h2><p>Before moving on to actual inference, we illustrate the key components of the library. We start by loading the data and constructing a simple model object.</p><p>The minimally required packages to do something useful are the following:</p><pre><code class="language-julia hljs">using Whale, NewickTree</code></pre><p>We will also load <code>Plots.jl</code> to have some graphics.</p><pre><code class="language-julia hljs">using Plots
default(legend=false, grid=false, framestyle=:box, size=(500,300))</code></pre><p>We will use the land plant example data set (which is available in the github repository). We shall need a species tree</p><pre><code class="language- hljs">datadir = joinpath(@__DIR__, &quot;../data/landplant&quot;)
tree = readnw(readline(joinpath(datadir, &quot;speciestree.nw&quot;)))</code></pre><p>... and a model object</p><pre><code class="language- hljs">rates = ConstantDLWGD(λ=0.1, μ=0.2, η=1/1.5)
model = WhaleModel(rates, tree, 0.01)</code></pre><p><code>rates</code> represents the model parameters: here we assume DLWGD (duplication, loss and WGD) model with constant duplication and loss rates across the species tree. We assume a duplication rate <span>$\lambda = 0.1$</span> and loss rate <span>$\mu = 0.2$</span>, with the number of genes at the root of a gene family distributed according to a Geometric distribution with mean <span>$1.5$</span> (i.e. <span>$\eta = 1/1.5$</span>). We combine the rates which parameterize the phylogenetic BDP model with the species tree in a <code>WhaleModel</code> object (<code>model</code>). The last argument to <code>WhaleModel</code> (here 0.01) determines the discretization of the species tree. This entails that we assume there to be at most one <em>represented</em> gene duplication event in each time slice of length <span>$0.01$</span>. This parameter should be adjusted relative to the branch lengths of the species tree.</p><p>Note that when the model object is printed to the screen, we get quite some information. In particular, under <code>Model structure</code> we get a CSV formatted table with header <code>node_id, wgd_id, distance, Δt, n, subtree</code>, here <code>n</code> shows the number of slices for the relevant branch of the species tree, i.e. the maximum number of represented gene duplication events along that branch. It is best to check whether these are large enough (at least 10 or so, except for the root).</p><p>Now we can load the gene tree distributions (CCDs)</p><pre><code class="language- hljs">data = read_ale(joinpath(datadir, &quot;100fams&quot;), model)</code></pre><p>Note that to load the CCDs (gene tree distributions), we need a <code>WhaleModel</code> object!</p><h2 id=".-The-loglikelihood"><a class="docs-heading-anchor" href="#.-The-loglikelihood">2. The loglikelihood</a><a id=".-The-loglikelihood-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-loglikelihood" title="Permalink"></a></h2><p>We can now, for instance, compute the log-likelihood for the first family</p><pre><code class="language- hljs">ℓ = logpdf(model, data[1])</code></pre><p>Or, assuming iid data, for the full data</p><pre><code class="language- hljs">ℓ = logpdf(model, data)</code></pre><p>One can easily reparameterize the model using the following syntax:</p><pre><code class="language- hljs">model = model((λ=0.2,μ=0.1))</code></pre><p>So that, for instance, we can easily graph a likelihood surface in the following way</p><pre><code class="language- hljs">plot(0:0.01:2, λ-&gt;logpdf(model((λ=λ, μ=λ)), data[1]), ylabel=&quot;\$\\ell\$&quot;, xlabel=&quot;\$\\lambda\$&quot;)</code></pre><p>(where we assumed <span>$\lambda = \mu$</span>). Note that the loglikelihood can be differentiated using forward-mode automatic differentiation (AD) with <code>ForwardDiff.jl</code>. The library is currently not compatible with reverse mode AD or other fancy stuff.</p><h2 id=".-Backtracking-reconciled-trees"><a class="docs-heading-anchor" href="#.-Backtracking-reconciled-trees">3. Backtracking reconciled trees</a><a id=".-Backtracking-reconciled-trees-1"></a><a class="docs-heading-anchor-permalink" href="#.-Backtracking-reconciled-trees" title="Permalink"></a></h2><p>We can sample a reconciled tree under the phylogenetic BDP using stochastic backtracking. That is, we sample a <em>reconciled</em> gene tree conditional on the <em>unreconciled</em> gene tree topology distribution and the likelihood under the model of gene family evolution:</p><pre><code class="language- hljs">ℓ = logpdf!(model, data)
G = Whale.backtrack(model, data[1])</code></pre><p>Note that the <code>logpdf!</code> step is crucial: the <code>data</code> is modified during the likelihood computations to enable backtracking.</p><p>The reconciled tree consists of nodes which look like this:</p><pre><code class="language- hljs">prewalk(G)[1:10]</code></pre><p>Here <code>σ</code> marks the species tree branch/node to which the gene tree node is reconciled. If a gene tree node is marked as a <code>duplication</code> with <code>σ=3</code>, this means for instance that this node represents a duplication event along the branch leading to node 3 of the species tree. <code>t</code> marks the time point along the branch of the species tree, going from present to past, where the gene tree node is reconciled to. Speciation events have <code>t=0</code> because they are mapped to the <em>nodes</em> in the species tree, instead of the branches (as duplication events are).</p><p>There are some plotting functions available, some better than others. The following plots the reconciled tree inside the species tree (duplication nodes in red, speciation nodes in blue)</p><pre><code class="language- hljs">plot(model, G, sscale=50.)</code></pre><p>toy around with <code>sscale</code> if the plot doesn&#39;t look good (or implement a new function and do a pull request!). Simply plotting the reconciled tree is also possible</p><pre><code class="language- hljs">plot(G, right_margin=30Plots.mm, size=(500,500))</code></pre><h2 id=".-Inference"><a class="docs-heading-anchor" href="#.-Inference">4. Inference</a><a id=".-Inference-1"></a><a class="docs-heading-anchor-permalink" href="#.-Inference" title="Permalink"></a></h2><p>With likelihoods available, one has many possibilities for conducting inference. I suggest using the <code>Turing.jl</code> library for probabilistic programming, potentially together with <code>Optim.jl</code> for maximum likelihood or maximum <em>a posteriori</em> estimation. You might want to get familiar with the basic syntax for specifying probabilistic models using Turing, please consult the relevant docs and tutorials at <a href="https://turing.ml/dev/">https://turing.ml</a>.</p><pre><code class="language- hljs">using Turing, Optim</code></pre><p>We can for instance consider the <span>$\lambda = \mu$</span> model for the first family, i.e. the problem for which we computed the likelihood curve above.</p><pre><code class="language- hljs">@model simplemodel(M, y, ::Type{T}=Float64) where T = begin
    λ ~ Exponential(0.2)
    y ~ M((λ=λ, μ=λ, q=T[]))
end</code></pre><p>Here we specify a probabilistic model with an Exponential(1) prior for the duplication (=loss) rate using <code>Turing.jl</code> syntax. Some minor annoyances with type stability lead to the <code>[...] ::Type{T}=Float64) where T</code> part and the explicit passing of <code>q=T[]</code> in the model object, sorry.</p><p>We can obtain a sample from the posterior using the NUTS algorithm</p><pre><code class="language- hljs">chain = sample(simplemodel(model, data[1]), NUTS(), 200)</code></pre><p>That makes sense. Alternatively, we can conduct MLE using <code>Optim</code> and <code>Turing</code>:</p><pre><code class="language- hljs">optimize(simplemodel(model, data[1]), MLE())</code></pre><p>Using probabilistic programs we can construct complicated hierarchical models of gene family evolution. Here&#39;s a very slight elaboration of the previous model, where we now assign a hyperprior to th number of lineages at the root:</p><pre><code class="language- hljs">@model secondmodel(M, y, ::Type{T}=Float64) where T = begin
    λ ~ Exponential(0.2)
    η ~ Beta(4,2)
    y ~ M((λ=λ, μ=λ, q=T[], η=η))
end</code></pre><p>we consider the first 10 families as data this time</p><pre><code class="language- hljs">chain = sample(secondmodel(model, data[1:10]), NUTS(), 200)</code></pre><p>Let&#39;s compare the <span>$\eta$</span> prior and posterior:</p><pre><code class="language- hljs">histogram(chain[:η], normalize=true, color=:white, xlabel=&quot;\$\\eta\$&quot;, ylabel=&quot;probability density&quot;)
plot!(0:0.01:1, x-&gt;pdf(Beta(4,2), x))</code></pre><h2 id=".-Sampling-reconciled-trees-from-the-posterior"><a class="docs-heading-anchor" href="#.-Sampling-reconciled-trees-from-the-posterior">5. Sampling reconciled trees from the posterior</a><a id=".-Sampling-reconciled-trees-from-the-posterior-1"></a><a class="docs-heading-anchor-permalink" href="#.-Sampling-reconciled-trees-from-the-posterior" title="Permalink"></a></h2><p>The interface for sampling reconciled trees from the posterior by stochastic backtracking is not so user-friendly yet and is due for some updates, but it is not difficult either. We first cast the chain as a data frame:</p><pre><code class="language- hljs">using DataFrames
df = DataFrame(chain);
nothing #hide</code></pre><p>We have to define a function which takes a model and a row from the dataframe (i.e. a sample from the posterior) and returns a model parameterized by that sample.</p><pre><code class="language-julia hljs">modelfun(M, x) = M((λ=x[:λ], μ=x[:λ], η=x[:η]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">modelfun (generic function with 1 method)</code></pre><p>Next we define the tracker</p><pre><code class="language- hljs">tracker = TreeTracker(model, data[1:10], df, modelfun)</code></pre><p>and we sample for each family 100 reconciled trees from the posterior, using the posterior sample in <code>df</code>.</p><pre><code class="language- hljs">out = track(tracker, 100)</code></pre><p>Each family has a <code>RecSummary</code> object, which among other things stores the sampled reconciled trees</p><pre><code class="language- hljs">out[1].trees</code></pre><p>This is the MAP tree of the first family:</p><pre><code class="language- hljs">out[1].trees[1]</code></pre><p>We plot the MAP tree for the first family</p><pre><code class="language- hljs">plot(out[1].trees[1].tree, cred=true, size=(500,500), right_margin=30Plots.mm)</code></pre><p>The numbers associated with each node indicate the estimated posterior probability that the reconciled tree contains this <em>split</em> reconciled as a duplication/speciation on that particular branch of the species tree.</p><h2 id=".-Events-and-orthology"><a class="docs-heading-anchor" href="#.-Events-and-orthology">6. Events and orthology</a><a id=".-Events-and-orthology-1"></a><a class="docs-heading-anchor-permalink" href="#.-Events-and-orthology" title="Permalink"></a></h2><p>We can summarize the number of events on each branch of the species tree using the following function:</p><pre><code class="language- hljs">smry = Whale.summarize(out)
smry.sum</code></pre><p>Here we <code>summary[1,&quot;duplication_mean&quot;]</code> will for instance record the posterior expected number of duplications per family along the branch leading to node 1.</p><p>Another useful output are the posterior probabilities for pairs of genes to be derived from certain events in the species tree</p><pre><code class="language- hljs">pairs = Whale.getpairs(out, model);
nothing #hide</code></pre><p>For instance, we can take a look at the first 10 gene pairs in this data frame. We first filter out all irrelevant columns:</p><pre><code class="language- hljs">idx = map(x-&gt;!all(x .== 0), eachcol(pairs[1:10,:]))
subset = pairs[1:10,idx]</code></pre><p>The estimated posterior probabilty that gene pair</p><pre><code class="language- hljs">subset[1,&quot;pair&quot;]</code></pre><p>... is derived from a duplication along the branch leading to node 21 is</p><pre><code class="language- hljs">subset[1,&quot;21_duplication&quot;]</code></pre><h2 id=".-Going-further"><a class="docs-heading-anchor" href="#.-Going-further">7. Going further</a><a id=".-Going-further-1"></a><a class="docs-heading-anchor-permalink" href="#.-Going-further" title="Permalink"></a></h2><p>For more details with regard to, for instance, the inference of ancient WGDs, or fitting more complicated model, consider having a look at the examples. If there are questions, comments, issues, or anything else, feel free to open issues on the gitub repository.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Index</a><a class="docs-footer-nextpage" href="../wgd-turing/">Bayesian inference for the DLWGD model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 12 September 2022 15:09">Monday 12 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
