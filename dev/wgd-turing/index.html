<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bayesian inference for the DLWGD model ¬∑ Whale.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Whale.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Bayesian inference for the DLWGD model</a><ul class="internal"><li><a class="tocitem" href="#Using-a-constant-rates-model"><span>Using a constant-rates model</span></a></li><li><a class="tocitem" href="#Maximum-likelihood-estimation"><span>Maximum-likelihood estimation</span></a></li><li><a class="tocitem" href="#Using-a-branch-specific-rates-model"><span>Using a branch-specific rates model</span></a></li><li><a class="tocitem" href="#Posterior-predictive-simulations"><span>Posterior predictive simulations</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Bayesian inference for the DLWGD model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bayesian inference for the DLWGD model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/arzwa/Whale.jl/blob/master/docs/src/wgd-turing.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bayesian-inference-for-the-DLWGD-model"><a class="docs-heading-anchor" href="#Bayesian-inference-for-the-DLWGD-model">Bayesian inference for the DLWGD model</a><a id="Bayesian-inference-for-the-DLWGD-model-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-inference-for-the-DLWGD-model" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Here it is assumed the reader is already familiar with the material outlined in the <a href="../tutorial/#Tutorial">Tutorial</a>.</p></div></div><pre><code class="language- hljs">using Whale, NewickTree, Distributions, Turing, DataFrames, LinearAlgebra
using Plots, StatsPlots
using Random; Random.seed!(7137);
nothing #hide</code></pre><p>plotting defaults</p><pre><code class="language- hljs">default(grid=false, size=(500,800), titlefontsize=9, title_loc=:left, guidefont=8)</code></pre><h2 id="Using-a-constant-rates-model"><a class="docs-heading-anchor" href="#Using-a-constant-rates-model">Using a constant-rates model</a><a id="Using-a-constant-rates-model-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-constant-rates-model" title="Permalink"></a></h2><p>First we will do inference for a simple constant-rates model (i.e. assuming a single duplication and loss rate for the entire species tree). First we load the species tree (using the example tree available in the Whale library)</p><pre><code class="language-julia hljs">t = deepcopy(Whale.extree)
n = length(postwalk(t))  # number of internal nodes</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">17</code></pre><p>Now we add two WGD nodes to the tree. We do this by specifying the last common ancestor node for the lineages that share the hypothetical WGD. By default, the added node is halfway between the specified node and its parent.</p><pre><code class="language-julia hljs">insertnode!(getlca(t, &quot;PPAT&quot;, &quot;PPAT&quot;), name=&quot;wgd_1&quot;)
insertnode!(getlca(t, &quot;ATHA&quot;, &quot;ATRI&quot;), name=&quot;wgd_2&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(((OSAT:1.555,(ATHA:0.5548,CPAP:0.5548):1.0002):0.738,ATRI:2.293):0.6125):0.6125;</code></pre><p>and we obtain a reference model object, using the constant-rates model with two WGDs</p><pre><code class="language-julia hljs">Œ∏ = ConstantDLWGD(Œª=0.1, Œº=0.2, q=[0.2, 0.1], Œ∑=0.9)
w = WhaleModel(Œ∏, t, .1, minn=10, maxn=20)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WhaleModel
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
‚ãÖParameterization:
ConstantDLWGD{Float64, Float64}
  Œª: Float64 0.1
  Œº: Float64 0.2
  q: Array{Float64}((2,)) [0.2, 0.1]
  p: Array{Float64}((0,)) Float64[]
  Œ∑: Float64 0.9

‚ãÖCondition:
Whale.RootCondition

‚ãÖModel structure:
19 nodes (9 leaves, 2 WGD nodes)
node_id,wgd_id,distance,Œît,n,subtree
1,0,4.752,0.2376,20,&quot;MPOL;&quot;
2,0,2.376,0.1188,20,&quot;PPAT;&quot;
3,0,4.457,0.2228,20,&quot;SMOE;&quot;
4,0,3.178,0.1589,20,&quot;GBIL;&quot;
5,0,3.178,0.1589,20,&quot;PABI;&quot;
6,0,1.555,0.0972,16,&quot;OSAT;&quot;
7,0,0.5548,0.0555,10,&quot;ATHA;&quot;
8,0,0.5548,0.0555,10,&quot;CPAP;&quot;
9,0,2.293,0.1146,20,&quot;ATRI;&quot;
18,1,2.376,0.1188,20,&quot;(PPAT);&quot;
10,0,0.292,0.0292,10,&quot;(MPOL,(PPAT));&quot;
11,0,0.34,0.034,10,&quot;(GBIL,PABI);&quot;
12,0,1.0002,0.0909,11,&quot;(ATHA,CPAP);&quot;
13,0,0.738,0.0738,10,&quot;(OSAT,(ATHA,CPAP));&quot;
14,0,0.6125,0.0613,10,&quot;((OSAT,(ATHA,CPAP)),ATRI);&quot;
19,2,0.6125,0.0613,10,&quot;(((OSAT,(ATHA,CPAP)),ATRI));&quot;
15,0,0.939,0.0939,10,&quot;((GBIL,PABI),(((OSAT,(ATHA,CPAP)),ATRI)));&quot;
16,0,0.587,0.0587,10,&quot;(SMOE,((GBIL,PABI),(((OSAT,(ATHA,CPAP)),ATRI))));&quot;
17,0,0.0,0.0,0,&quot;((MPOL,(PPAT)),(SMOE,((GBIL,PABI),(((OSAT,(ATHA,CPAP)),ATRI)))));&quot;
</code></pre><p>next we get the data (we need a model object for that)</p><pre><code class="language-julia hljs">data = joinpath(@__DIR__, &quot;../../example/example-1/ale&quot;)
ccd = read_ale(data, w)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12-element Vector{CCD{UInt16, Float64}}:
 CCD{UInt16,Float64}(Œì=83, ùìõ=13)
 CCD{UInt16,Float64}(Œì=55, ùìõ=13)
 CCD{UInt16,Float64}(Œì=89, ùìõ=13)
 CCD{UInt16,Float64}(Œì=131, ùìõ=13)
 CCD{UInt16,Float64}(Œì=107, ùìõ=13)
 CCD{UInt16,Float64}(Œì=59, ùìõ=13)
 CCD{UInt16,Float64}(Œì=53, ùìõ=13)
 CCD{UInt16,Float64}(Œì=83, ùìõ=13)
 CCD{UInt16,Float64}(Œì=59, ùìõ=13)
 CCD{UInt16,Float64}(Œì=95, ùìõ=13)
 CCD{UInt16,Float64}(Œì=67, ùìõ=13)
 CCD{UInt16,Float64}(Œì=65, ùìõ=13)</code></pre><p>Now we define the Turing model</p><pre><code class="language- hljs">@model constantrates(model, ccd) = begin
    Œª  ~ Exponential()
    Œº  ~ Exponential()
    Œ∑  ~ Beta(3,1)
    q1 ~ Beta()
    q2 ~ Beta()
    ccd ~ model((Œª=Œª, Œº=Œº, Œ∑=Œ∑, q=[q1, q2]))
end</code></pre><p>In this model we have line by line:</p><ul><li><code>Œª</code> and <code>Œº</code>: the duplication and loss rate, for which we assume Exponential priors.</li><li><code>Œ∑</code>: the parameter of the geometric prior distribution on the number of genes at the root (i.e. the Whale likelihood is integrated over a geometric prior for the number of ancestral genes)</li><li><code>q1</code>: the retention rate for the first WGD (with a uniform prior on [0,1], i.e. Beta(1,1))</li><li><code>q2</code>: as <code>q1</code></li><li><code>ccd ~ model(...)</code>: here we specify the likelihood, we assume the data (<code>ccd</code>) is iid from the duplication+loss+WGD model with the relevant parameters.</li></ul><pre><code class="language- hljs">chain0 = sample(constantrates(w, ccd), NUTS(), 200)</code></pre><p>Making some trace plots is straightforward using tools from the Turing probabilistic programming ecosystem</p><pre><code class="language- hljs">plot(chain0, size=(700,900))</code></pre><p>We can compute Bayes factors for the WGD hypotheses</p><pre><code class="language- hljs">summarize(chain0[[:q1,:q2]], Whale.bayesfactor)</code></pre><p>This is the log10 Bayes factor in favor of the <span>$q = 0$</span> model. A Bayes factor smaller than -2 could be considered as evidence in favor of the <span>$q \ne 0$</span> model <em>compared to the <span>$q=0$</span> model</em>. This in itself need not say much, as it says nothing about how well the model actually fits the data.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Of course the chain should be run longer than in this example! Here a short chain is presented to ensure reasonable build times for this documentation. Generally, one should at least strive for ESS values exceeding at least 100, although short chains may be good for exploring and testing different models.</p></div></div><p>Now let&#39;s obtain reconciled trees</p><pre><code class="language- hljs">posterior = DataFrame(chain0)
ffun = (m, x)-&gt;m((Œª=x[:Œª], Œº=x[:Œº], Œ∑=x[:Œ∑], q=[x[:q1], x[:q2]]))
tt = TreeTracker(w, ccd, posterior, ffun)
trees = track(tt, 1000)</code></pre><p>Note that <code>fun</code> is a function that takes the model object and a row from the posterior data frame, returning a model parameterized by the posterior sample in the row <code>x</code>.</p><p>Let&#39;s have a look at the first family</p><pre><code class="language- hljs">trees[1].trees</code></pre><p>We can write these to a file using <code>Whale.writetrees(&quot;filename.nw&quot;, trees[1].trees)</code> if we would want that.  The maximum a posterior tree for this family is</p><pre><code class="language- hljs">map1 = trees[1].trees[1]
nwstr(map1.tree)</code></pre><p>with posterior probability</p><pre><code class="language- hljs">map1.freq</code></pre><p>Or maybe all the gene pairs</p><pre><code class="language- hljs">ps = Whale.getpairs(trees, w);
nothing #hide</code></pre><p>Now let&#39;s look at the gene pairs which have a non-zero posterior probability of being derived from WGD node 18 (the <em>P. patens</em> WGD, execute <code>@show w</code> to check the model structure)</p><pre><code class="language- hljs">p = filter(x-&gt;x[Symbol(&quot;18_wgd&quot;)] &gt; 0.0, ps)[!,:pair]</code></pre><p>Now we can look at the complete posterior reconciliation distribution for these gene pairs</p><pre><code class="language- hljs">df18 = filter(x-&gt;x[:pair] ‚àà p, ps)
df18[:,[!(all(col .== 0)) for col in eachcol(df18)]]  # filter out all zero columns...</code></pre><p>The column names are <code>&lt;branch id&gt;_&lt;event&gt;</code>, and the entries are the posterior probability that the gene pair is reconciled to the relevant branch + event combination.</p><p>Here we have for each WGD event in the tree all gene pairs that have non-zero posterior probability (as measured by the frequency in the posterior sample) to be reconciled to the relevant WGD event.</p><p>A table summarizing events for each branch can be obtained as well</p><pre><code class="language- hljs">smry = Whale.summarize(trees)
smry.sum</code></pre><p>here we have the expected number of duplications, losses, etc. per family for the different branches in the species tree (the row associated with a node corresponds to the branch leading to that node)</p><h2 id="Maximum-likelihood-estimation"><a class="docs-heading-anchor" href="#Maximum-likelihood-estimation">Maximum-likelihood estimation</a><a id="Maximum-likelihood-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-likelihood-estimation" title="Permalink"></a></h2><pre><code class="language- hljs">using Optim
result = optimize(constantrates(w, ccd), MLE())</code></pre><p>One could now compute the likelihood using the model without WGD 1 and/or 2 and compare the likelihoods using a likelihood ratio test as in Rabier et al. (2014) to assess whether the data is compatible with the hypothesis <span>$q = 0$</span> (which should represent absence of a WGD).</p><h2 id="Using-a-branch-specific-rates-model"><a class="docs-heading-anchor" href="#Using-a-branch-specific-rates-model">Using a branch-specific rates model</a><a id="Using-a-branch-specific-rates-model-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-branch-specific-rates-model" title="Permalink"></a></h2><p>Now we will consider a model with branch-specific duplication and loss rates, using a more complicated hierarchical model with an uncorrelated relaxed clock model.  We&#39;ll use the same tree as above. The relevant model now is the DLWGD model:</p><pre><code class="language-julia hljs">Œ∏ = DLWGD(Œª=zeros(n), Œº=zeros(n), q=rand(2), Œ∑=rand())
w = WhaleModel(Œ∏, t, 0.1)
ccd = read_ale(data, w)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12-element Vector{CCD{UInt16, Float64}}:
 CCD{UInt16,Float64}(Œì=83, ùìõ=13)
 CCD{UInt16,Float64}(Œì=55, ùìõ=13)
 CCD{UInt16,Float64}(Œì=89, ùìõ=13)
 CCD{UInt16,Float64}(Œì=131, ùìõ=13)
 CCD{UInt16,Float64}(Œì=107, ùìõ=13)
 CCD{UInt16,Float64}(Œì=59, ùìõ=13)
 CCD{UInt16,Float64}(Œì=53, ùìõ=13)
 CCD{UInt16,Float64}(Œì=83, ùìõ=13)
 CCD{UInt16,Float64}(Œì=59, ùìõ=13)
 CCD{UInt16,Float64}(Œì=95, ùìõ=13)
 CCD{UInt16,Float64}(Œì=67, ùìõ=13)
 CCD{UInt16,Float64}(Œì=65, ùìõ=13)</code></pre><p>Note that the duplication and loss rates should here be specified on a log-scale for the DLWGD model. We assume a Normal prior for the mean duplication and loss rates, and assume the log-scale branch-specific rates to be distributed according to a multivariate normal with diagonal covariance matrix <span>$\tau I$</span>. We assume duplication and loss rates to be independent.</p><pre><code class="language- hljs">@model branchrates(model, n, ccd, ::Type{T}=Float64) where T = begin
    Œ∑ ~ Beta(3,1)
    ŒªÃÑ ~ Normal(log(0.15), 2)
    ŒºÃÑ ~ Normal(log(0.15), 2)
    œÑ ~ Exponential(0.1)
    Œª ~ MvNormal(fill(ŒªÃÑ, n-1), œÑ)
    Œº ~ MvNormal(fill(ŒºÃÑ, n-1), œÑ)
    q1 ~ Beta()
    q2 ~ Beta()
    ccd ~ model((Œª=Œª, Œº=Œº, Œ∑=Œ∑, q=[q1, q2]))
end</code></pre><p>... and sample (this takes a bit longer!)</p><pre><code class="language- hljs">chain1 = sample(branchrates(w, n, ccd), NUTS(), 200)</code></pre><p>Make a plot for the retention parameters</p><pre><code class="language- hljs">plot(chain1[[:q1,:q2]], size=(700,300))</code></pre><h2 id="Posterior-predictive-simulations"><a class="docs-heading-anchor" href="#Posterior-predictive-simulations">Posterior predictive simulations</a><a id="Posterior-predictive-simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Posterior-predictive-simulations" title="Permalink"></a></h2><p>We can do posterior predictive simulations to assess model fit. There are of course many possible posterior predictive observables that we may employ to do so. The approach below is but one that is (partially) implemented. Here we compare simulated number of events for each branch with reconstructed number of events for each branch. That is, for <span>$N$</span> samples from the posterior, we (1) simulate a data set of the size of our empirical data set and (2) sample a reconciled tree for each gene family. We then compare, for instance, the number of duplications on the branch leading to node <span>$m$</span> in the two simulated sets. If the model fits these should be similar.</p><p>We need a function to get a parameterized model from a chain iterate:</p><pre><code class="language-julia hljs">function mfun(M, x)
    q1 = get(x, :q1).q1[1]
    q2 = get(x, :q2).q2[1]
    Œª = vec(vcat(get(x, :Œª).Œª...))
    Œº = vec(vcat(get(x, :Œº).Œº...))
    Œ∑ = get(x, :Œ∑).Œ∑[1]
    M((Œª=Œª, Œº=Œº, q=[q1,q2], Œ∑=Œ∑))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">mfun (generic function with 1 method)</code></pre><p>The following will then do 100 posterior predictive simulations</p><pre><code class="language- hljs">pps = Whale.ppsims(chain1, mfun, w, ccd, 100);
nothing #hide</code></pre><p>and we make a plot for duplication events</p><pre><code class="language- hljs">lab = &quot;duplication&quot;
ps = map(w.order) do mnode
    l = &quot;$(id(mnode))_$lab&quot;
    dots = map(x-&gt;(x[1][l], x[2][l]), pps)
    xmn, xmx = extrema(vcat(first.(dots), first.(dots)))
    scatter(dots, color=:black, ms=2, alpha=0.5, legend=false,
            xlabel=&quot;\$y\$&quot;, ylabel=&quot;\$\\tilde{y}\$&quot;,
            title=Whale.cladelabel(mnode),
            xlim=(xmn-0.5,xmx+0.5), xticks=xmn:1:xmx)
    plot!(x-&gt;x, color=:lightgray)
end
plot(ps..., size=(700,600))</code></pre><p>one can of course also compare loss events, speciation events, WGD-derived duplicates etc.</p><p>The above is somewhat more informative when analyzing more data. Using this approach on <code>chain0</code> and comparing against the results displayed here, one could for instance check whether the constant rates assumption is strongly violated or not. If the dots in these plots are not systematically above or below the 1-1 line, at least this aspect of the data is explained well by the model.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>I know that this, and the sampling methods for reconciled trees, should be implemented in a somewhat more consistent and user-friendly style. It&#39;s on the to-do list.</p></div></div><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">¬´ Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 12 September 2022 15:19">Monday 12 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
